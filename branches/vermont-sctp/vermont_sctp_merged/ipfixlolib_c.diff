--- /home/alex/uni/vermont-sctp/ipfixlolib/ipfixlolib.c	2007-09-18 15:23:39.000000000 +0000
+++ ipfixlolib/ipfixlolib.c	2007-07-27 00:10:59.000000000 +0000
@@ -23,10 +23,13 @@
  */
 #include "ipfixlolib.h"
 #include <netinet/in.h>
-//#include <sctp.h>
-/* foreign systems */
-#include "msg.h"
 
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+/* foreign systems */
+#include "common/msg.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -34,9 +37,7 @@ extern "C" {
 
 #define bit_set(data, bits) ((data & bits) == bits)
 
-
-static int init_send_sctp_socket(struct sockaddr_in serv_addr);
-static int init_send_udp_socket(struct sockaddr_in serv_addr);
+static int init_send_udp_socket(const char *serv_ip4_addr, int serv_port);
 static int ipfix_find_template(ipfix_exporter *exporter, uint16_t template_id, enum ipfix_validity cleanness);
 static int ipfix_prepend_header(ipfix_exporter *p_exporter, int data_length, ipfix_sendbuffer *sendbuf);
 static int ipfix_init_sendbuffer(ipfix_sendbuffer **sendbufn);
@@ -44,14 +45,13 @@ static int ipfix_reset_sendbuffer(ipfix_
 static int ipfix_deinit_sendbuffer(ipfix_sendbuffer **sendbuf);
 static int ipfix_init_collector_array(ipfix_receiving_collector **col, int col_capacity);
 static int ipfix_deinit_collector_array(ipfix_receiving_collector **col);
-static int ipfix_init_send_socket(struct sockaddr_in serv_addr , enum ipfix_transport_protocol protocol);
+static int ipfix_init_send_socket(const char *serv_ip4_addr, int serv_port, enum ipfix_transport_protocol protocol);
 static int ipfix_init_template_array(ipfix_exporter *exporter, int template_capacity);
 static int ipfix_deinit_template_array(ipfix_exporter *exporter);
 static int ipfix_update_template_sendbuffer(ipfix_exporter *exporter);
 static int ipfix_send_templates(ipfix_exporter* exporter);
 static int ipfix_send_data(ipfix_exporter* exporter);
 
-
 #if 0
 static int init_rcv_udp_socket(int lport);
 /* NOT USED */
@@ -93,16 +93,16 @@ static int init_rcv_udp_socket(int lport
  * serv_port the UDP-portnumber of the server.
  * Returns: a socket to write to. -1 on failure
  */
-static int init_send_udp_socket(struct sockaddr_in serv_addr){
+static int init_send_udp_socket(const char *serv_ip4_addr, int serv_port){
 
         int s;
-        /*struct sockaddr_in serv_addr;
+        struct sockaddr_in serv_addr;
 
         memset(&serv_addr, 0, sizeof(serv_addr));
         serv_addr.sin_family = AF_INET;
         serv_addr.sin_port = htons (serv_port);
         serv_addr.sin_addr.s_addr = inet_addr(serv_ip4_addr);
-*/
+
         // create socket
         if((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
                 msg(MSG_FATAL, "IPFIX: error opening socket, %s", strerror(errno));
@@ -121,117 +121,6 @@ static int init_send_udp_socket(struct s
 }
 
 
-/********************************************************************
-** SCTP Extension Code: TODO:PR-Functionality
-*********************************************************************/
-/*
- * Initializes a SCTP-socket to send data to.
- * Parameters:
- * char* serv_ip4_addr IP-Address of the recipient (e.g. "123.123.123.123")
- * serv_port the SCTP-portnumber of the server.
- * Returns: a socket to write to. -1 on failure
- */
-static int init_send_sctp_socket(struct sockaddr_in serv_addr){
-	
-	int s;
-	/*struct sockaddr_in serv_addr;
-	
-	memset(&serv_addr, 0, sizeof(serv_addr));
-	serv_addr.sin_family = AF_INET;
-	serv_addr.sin_port = htons (serv_port);
-	serv_addr.sin_addr.s_addr = inet_addr(serv_ip4_addr);
-	*/
-	
-	//create socket:
-	msg(MSG_DEBUG, "Creating SCTP Socket ...");
-	if((s = socket(PF_INET, SOCK_STREAM, IPPROTO_SCTP)) < 0 ) {
-                msg(MSG_FATAL, "IPFIX: error opening SCTP socket, %s", strerror(errno));
-                return -1;
-        }
-	msg(MSG_DEBUG, "SCTP Socket created");
-	
-	//seting up SCTP Options	
-
- 	struct sctp_initmsg init_info;
- 	uint leng = sizeof(struct sctp_initmsg);
- 	if( (getsockopt(s,IPPROTO_SCTP,SCTP_INITMSG, &init_info, &leng)) < 0){
- 		perror("ERROR GETTING SOCKOPTIONS!!! ");
- 	}else {printf("SOCKOPTIONS: Number of in/outstreams = %d/%d\n", init_info.sinit_num_ostreams, init_info.sinit_max_instreams);}
-/*
-	struct sctp_initmsg m;
-	m.sinit_num_ostreams = 2;
-	m.sinit_max_instreams = 2;
- 	if( (setsockopt(s,IPPROTO_SCTP,SCTP_INITMSG, &m, sizeof(m) )) < 0){
- 		perror("ERROR SETTING SOCKOPTIONS!!! \n");
- 	}else {msg(MSG_DEBUG,"SOCKOPTIONS SET!");}
-	//TODO getsockopt() kann gelöshct werden nicht mehr nötig wenn SCTP funktioniert
-	if( (getsockopt(s,IPPROTO_SCTP,SCTP_INITMSG, &init_info, &leng)) < 0){
- 		perror("ERROR GETTING SOCKOPTIONS!!! ");
- 	}else {msg(MSG_DEBUG,"SOCKOPTIONS: Max number of in/outstreams = %d/%d", init_info.sinit_num_ostreams, init_info.sinit_max_instreams);}
-*/	//END SCTP options
-
-	// connect to server
-	//msg(MSG_DEBUG, "SCTP connecting to %s:%i ...",serv_addr.sin_addr.s_addr,serv_addr.sin_port );
-	if(connect(s, (struct sockaddr*)&serv_addr, sizeof(serv_addr) ) < 0) {
-		msg(MSG_FATAL, "IPFIX: SCTP connect failed, %s", strerror(errno));
-		/* clean up */
-		close(s);
-		return -1;
-	}
-	//msg(MSG_DEBUG, "SCTP connected to %s:%i",serv_addr.sin_addr.s_addr,serv_addr.sin_port );
-	return s;
-}
-
-/*
- * modification of the original sctp_sendmsg to handle iovec structs
- * Parameters:
- * s : socket
- * *vector : iovec struct containing the buffer to send
- * v_len : lenght of the buffer
- * *to : address where data is going to be sent
- * tolen : length of the address
- * ppid, flags, stream_no, timetolive, context : sctp parameters
- */
-int sctp_sendmsgv(int s, struct iovec *vector, int v_len, struct sockaddr *to,
-		socklen_t tolen, uint32_t ppid, uint32_t flags,
-	     	uint16_t stream_no, uint32_t timetolive, uint32_t context){
-
-	struct msghdr outmsg;
-	char outcmsg[CMSG_SPACE(sizeof(struct sctp_sndrcvinfo))];
-	struct cmsghdr *cmsg;
-	struct sctp_sndrcvinfo *sinfo;
-
-	outmsg.msg_name = to;
-	outmsg.msg_namelen = tolen;
-	outmsg.msg_iov = vector;
-	outmsg.msg_iovlen = v_len;
-
-	outmsg.msg_control = outcmsg;
-	outmsg.msg_controllen = sizeof(outcmsg);
-	outmsg.msg_flags = 0;
-
-	cmsg = CMSG_FIRSTHDR(&outmsg);
-	cmsg->cmsg_level = IPPROTO_SCTP;
-	cmsg->cmsg_type = SCTP_SNDRCV;
-	cmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndrcvinfo));
-
-	outmsg.msg_controllen = cmsg->cmsg_len;
-	sinfo = (struct sctp_sndrcvinfo *)CMSG_DATA(cmsg);
-	memset(sinfo, 0, sizeof(struct sctp_sndrcvinfo));
-	sinfo->sinfo_ppid = ppid;
-	sinfo->sinfo_flags = flags;
-	sinfo->sinfo_stream = stream_no;
-	sinfo->sinfo_timetolive = timetolive;
-	sinfo->sinfo_context = context;
-
-	return sendmsg(s, &outmsg, 0);
-}
-
-
-/********************************************************************
-//END of SCTP Extension Code:
-*********************************************************************/
-
 /*
  * Initialize an exporter process
  * Allocates all memory necessary.
@@ -253,6 +142,7 @@ int ipfix_init_exporter(uint32_t source_
         tmp->collector_num = 0; // valgrind kindly asked me to inititalize this value JanP
         tmp->collector_max_num = 0;
 
+
         // initialize the sendbuffers
         ret=ipfix_init_sendbuffer(&(tmp->data_sendbuffer));
         if (ret != 0) {
@@ -266,19 +156,13 @@ int ipfix_init_exporter(uint32_t source_
                 goto out2;
         }
 
-	ret=ipfix_init_sendbuffer(&(tmp->sctp_template_sendbuffer));
-        if (ret != 0) {
-                msg(MSG_FATAL, "IPFIX: initializing sctp template sendbuffer failed");
-                goto out5;
-        }
-
         // intialize the collectors to zero
         ret=ipfix_init_collector_array( &(tmp->collector_arr), IPFIX_MAX_COLLECTORS);
         if (ret !=0) {
                 msg(MSG_FATAL, "IPFIX: initializing collectors failed");
                 goto out3;
         }
-	
+
         tmp->collector_max_num = IPFIX_MAX_COLLECTORS;
 
         // initialize an array to hold the templates.
@@ -298,8 +182,6 @@ int ipfix_init_exporter(uint32_t source_
 
         return 0;
 
-out5:
-        ipfix_deinit_sendbuffer(&(tmp->sctp_template_sendbuffer));
 out4:
         ipfix_deinit_collector_array(&(tmp->collector_arr));
 out3:
@@ -335,7 +217,6 @@ int ipfix_deinit_exporter(ipfix_exporter
         // deinitialize the sendbuffers
         ret=ipfix_deinit_sendbuffer(&(exporter->data_sendbuffer));
         ret=ipfix_deinit_sendbuffer(&(exporter->template_sendbuffer));
-	ret=ipfix_deinit_sendbuffer(&(exporter->sctp_template_sendbuffer));
 
         // deinitialize the collectors
         ret=ipfix_deinit_collector_array(&(exporter->collector_arr));
@@ -363,7 +244,7 @@ int ipfix_add_collector(ipfix_exporter *
         int i=0;
         int searching = TRUE;
 
-        DPRINTF("ipfix_add_collector start\n");
+        DPRINTFL(MSG_VDEBUG, "ipfix_add_collector start");
 
         // check, if exporter is valid
         if(exporter == NULL) {
@@ -378,10 +259,11 @@ int ipfix_add_collector(ipfix_exporter *
                    );
                 return -1;
         }
-        DPRINTF("ipfix_add_collector searching\n");
+        DPRINTFL(MSG_VDEBUG, "ipfix_add_collector searching");
+
         while (searching && ( i< exporter->collector_max_num) ) {
 
-                DPRINTF("ipfix_add_collector searching %i, i %i \n", searching, i);
+                DPRINTFL(MSG_VDEBUG, "ipfix_add_collector searching %i, i %i ", searching, i);
                 if(exporter->collector_arr[i].valid == FALSE) {
                         // we have found a free slot:
                         /*
@@ -392,25 +274,31 @@ int ipfix_add_collector(ipfix_exporter *
                         strncpy(exporter->collector_arr[i].ipv4address, coll_ip4_addr, 16);
                         exporter->collector_arr[i].port_number = coll_port;
                         exporter->collector_arr[i].protocol = proto;
-			
-			memset(&(exporter->collector_arr[i].addr), 0, sizeof(exporter->collector_arr[i].addr));
-			exporter->collector_arr[i].addr.sin_family = AF_INET;
-			exporter->collector_arr[i].addr.sin_port = htons (coll_port);
-			exporter->collector_arr[i].addr.sin_addr.s_addr = inet_addr(coll_ip4_addr);
-			
-                        // open the socket: call an own function.
-                        exporter->collector_arr[i].data_socket = ipfix_init_send_socket( exporter->collector_arr[i].addr, proto);
-
-                        // error handling, in case we were unable to open the port:
-                        if(exporter->collector_arr[i].data_socket < 0 ) {
-                                msg(MSG_ERROR, "IPFIX: add collector %s:%i, initializing socket failed",
-                                    coll_ip4_addr, coll_port
-                                   );
-                                return -1;
-                        }
-                        // currently, the data socket and the template socket are the same.
-                        // TODO, when SCTP is added!
-                        exporter->collector_arr[i].template_socket = exporter->collector_arr[i].data_socket;
+
+#ifdef IPFIXLOLIB_RAWDIR_SUPPORT
+			if (proto != RAWDIR) {
+#endif
+
+	                        // open the socket: call an own function.
+        	                exporter->collector_arr[i].data_socket = ipfix_init_send_socket( coll_ip4_addr, coll_port, proto);
+
+	                        // error handling, in case we were unable to open the port:
+	                        if(exporter->collector_arr[i].data_socket < 0 ) {
+	                                msg(MSG_ERROR, "IPFIX: add collector %s:%i, initializing socket failed",
+	                                    coll_ip4_addr, coll_port
+	                                   );
+	                                return -1;
+	                        }
+	                        // currently, the data socket and the template socket are the same.
+	                        // TODO, when SCTP is added!
+	                        exporter->collector_arr[i].template_socket = exporter->collector_arr[i].data_socket;
+#ifdef IPFIXLOLIB_RAWDIR_SUPPORT
+			}
+			if (proto == RAWDIR) {
+				exporter->collector_arr[i].packet_directory_path = strdup(coll_ip4_addr);
+				exporter->collector_arr[i].packets_written = 0;
+			}
+#endif
 
                         // now, we may set the collector to valid;
                         exporter->collector_arr[i].valid = UNCLEAN;
@@ -442,14 +330,24 @@ int ipfix_remove_collector(ipfix_exporte
                    && exporter->collector_arr[i].port_number == coll_port
                   )  {
 
-                        // are template and data socket the same?
-                        if( exporter->collector_arr[i].template_socket ==  exporter->collector_arr[i].data_socket ) {
-                                close ( exporter->collector_arr[i].data_socket );
-                        } else { //close both connections:
-                                close (exporter->collector_arr[i].data_socket );
-                                close (exporter->collector_arr[i].template_socket );
-                        }
-			exporter->collector_arr[i].valid = FALSE;
+#ifdef IPFIXLOLIB_RAWDIR_SUPPORT
+			if (exporter->collector_arr[i].protocol != RAWDIR) {
+#endif
+				// are template and data socket the same?
+				if( exporter->collector_arr[i].template_socket ==  exporter->collector_arr[i].data_socket ) {
+					close ( exporter->collector_arr[i].data_socket );
+				} else { //close both connections:
+					close (exporter->collector_arr[i].data_socket );
+					close (exporter->collector_arr[i].template_socket );
+				}
+#ifdef IPFIXLOLIB_RAWDIR_SUPPORT
+			}
+			if (exporter->collector_arr[i].protocol == RAWDIR) {
+				free(exporter->collector_arr[i].packet_directory_path);
+			}
+#endif
+
+                        exporter->collector_arr[i].valid = FALSE;
                         searching = FALSE;
                 }
                 i++;
@@ -474,14 +372,12 @@ int ipfix_remove_collector(ipfix_exporte
  * Parmeters:
  * exporter: Exporter to search for the template
  * template_id: ID of the template we search
- * cleanness: search for UNUSED templates or for existing by ID
+ * cleanness: search for COMMITED or UNCLEAN templates? May even search for UNUSED templates
  * Returns: the index of the template in the exporter or -1 on failure.
  */
 
 static int ipfix_find_template(ipfix_exporter *exporter, uint16_t template_id, enum ipfix_validity cleanness)
 {
-	msg(MSG_DEBUG, "IPFIX: ipfix_find_template with ID: %d",template_id);
-
         int i=0;
         int searching;
 
@@ -494,38 +390,35 @@ static int ipfix_find_template(ipfix_exp
                 msg(MSG_ERROR, "IPFIX: find_template, template array not initialized, cannot search for %d", template_id);
                 return -1;
         }
+
         // do we already have a template with this ID?
         // -> update it!
-        
         searching = TRUE;
-        if (cleanness == UNUSED) {
-		while(searching && ( i< exporter->ipfix_lo_template_maxsize) ) {
-			if( exporter->template_arr[i].valid == cleanness) {
-					// we found an unused slot; return the index:
-					return i;
-			}
-			i++;
-		}
-	}else{
-		while(searching && ( i< exporter->ipfix_lo_template_maxsize) ) {
-//  			if( exporter->template_arr[i].valid == cleanness) {
-				// we are searching for an existing template, compare the template_id:
-				if(exporter->template_arr[i].template_id == template_id) {
-					msg(MSG_DEBUG, "IPFIX: ipfix_find_template with ID: %d, validity %d found at %d", template_id, exporter->template_arr[i].valid, i);
-					return i;
-					searching = FALSE;
-				}
-	
-//  			}
-			i++;
-		}
-	}
+        while(searching && ( i< exporter->ipfix_lo_template_maxsize) ) {
+
+                if( exporter->template_arr[i].valid == cleanness) {
+                        // if we are searching for an existing template, compare the template_id too:
+                        if( (cleanness == COMMITED) || (cleanness = UNCLEAN) ) {
+
+                                if(exporter->template_arr[i].template_id == template_id) {
+                                        return i;
+                                        searching = FALSE;
+                                }
+
+                        } else {
+                                // we found an unused slot; return the index:
+                                return i;
+                        }
+                }
+                i++;
+        }
+
         return -1;
 }
 
 
 /*
- * Remove a template from the exporting process but create a withdrawal message first
+ * Remove a template from the exporting process
  * Parameters:
  * exporter: the exporter
  * template_id: ID of the template to remove
@@ -535,39 +428,18 @@ static int ipfix_find_template(ipfix_exp
 int ipfix_remove_template_set(ipfix_exporter *exporter, uint16_t template_id)
 {
         int ret = 0;
-	// argument SENT is ignored in ipfix_find_template
-        int found_index = ipfix_find_template(exporter,template_id, SENT);
-	if (found_index >= 0) {
-		if( (exporter->template_arr[found_index].valid == SENT) || ((exporter->template_arr[found_index].valid == COMMITED)) ){
-			msg(MSG_DEBUG, "IPFIX: ipfix_remove_template_set: creating withdrawal msg for ID: %d, validity %d", template_id, exporter->template_arr[found_index].valid);
-			char *p_pos;
-			char *p_end;
-	
-			// write the withdrawal message fields into the buffer
-			// beginning of the buffer
-			p_pos = exporter->template_arr[found_index].template_fields;
-			// end of the buffer since the WITHDRAWAL message for one template is always 8 byte
-			p_end = p_pos + 8;
-	
-			// set ID is 2 for a template, 4 for a template with fixed fields:
-			// for withdrawal masseges we keep the template set ID
-			p_pos +=  2;
-			// write 8 to the lenght field
-			write_unsigned16 (&p_pos, p_end, 8);
-			// keep the template ID:
-			p_pos +=  2;
-			// write 0 for the field count, since it indicates that this is a withdrawal message
-			write_unsigned16 (&p_pos, p_end, 0);
-			exporter->template_arr[found_index].fields_length = 8;
-			exporter->template_arr[found_index].field_count = 0;
-			exporter->template_arr[found_index].valid = WITHDRAWN;
-			msg(MSG_DEBUG, "IPFIX: ipfix_remove_template_set: ... Withdrawn");
-		}
-	}else {
-		msg(MSG_ERROR, "IPFIX: remove_template ID %u not found", template_id);
-		return -1;
-	}
-	return ret;
+
+        // TODO: maybe, we have to clean up unclean templates too:
+        int found_index = ipfix_find_template(exporter,template_id, COMMITED);
+
+        if (found_index >= 0) {
+                ret=ipfix_deinit_template_set(exporter, &(exporter->template_arr[found_index]));
+        }else {
+                msg(MSG_ERROR, "IPFIX: remove_template ID %u not found", template_id);
+                return -1;
+        }
+
+        return ret;
 }
 
 /************************************************************************************/
@@ -762,13 +634,13 @@ static int ipfix_deinit_collector_array(
  * serv_port: port
  * protocol: transport protocol
  */
-static int ipfix_init_send_socket(struct sockaddr_in serv_addr, enum ipfix_transport_protocol protocol)
+static int ipfix_init_send_socket(const char *serv_ip4_addr, int serv_port, enum ipfix_transport_protocol protocol)
 {
         int sock = -1;
 
         switch(protocol) {
         case UDP:
-                sock= init_send_udp_socket( serv_addr );
+                sock= init_send_udp_socket( serv_ip4_addr, serv_port);
                 break;
 
         case TCP:
@@ -776,9 +648,14 @@ static int ipfix_init_send_socket(struct
                 break;
 
         case SCTP:
-                sock= init_send_sctp_socket( serv_addr );
-//                 msg(MSG_FATAL, "IPFIX: Transport Protocol SCTP not implemented");
+                msg(MSG_FATAL, "IPFIX: Transport Protocol SCTP not implemented");
+                break;
+
+#ifdef IPFIXLOLIB_RAWDIR_SUPPORT
+	case RAWDIR:
+                msg(MSG_FATAL, "IPFIX: Transport Protocol RAWDIR cannot be used to open a socket");
 		break;
+#endif
 
         default:
                 msg(MSG_FATAL, "IPFIX: Transport Protocol not supported");
@@ -801,7 +678,7 @@ static int ipfix_init_template_array(ipf
 {
         int i;
 
-        DPRINTF("IPFIX - ipfix_init_template_array with elem %d\n", template_capacity);
+        DPRINTFL(MSG_VDEBUG, "IPFIX - ipfix_init_template_array with elem %d", template_capacity);
         // allocate the memory for template_capacity elements:
         exporter->ipfix_lo_template_maxsize  = template_capacity;
         exporter->ipfix_lo_template_current_count = 0 ;
@@ -830,20 +707,10 @@ static int ipfix_deinit_template_array(i
         int ret = 0;
         
 	for(i=0; i< exporter->ipfix_lo_template_maxsize; i++) {
-                // if template was sent we need a withdrawal message first
-                if (exporter->template_arr[i].valid == SENT){
-                 	ret = ipfix_remove_template_set(exporter, exporter->template_arr[i].template_id );
-                }
-        }
-        // send all created withdrawal messages
-        ipfix_send_templates(exporter);
-        
-	for(i=0; i< exporter->ipfix_lo_template_maxsize; i++) {
-		// try to free all templates:
-		ret = ipfix_deinit_template_set(exporter, &(exporter->template_arr[i]) );
-		
+                // try to free all templates:
+                ret = ipfix_deinit_template_set(exporter, &(exporter->template_arr[i]) );
                 // for debugging:
-                DPRINTF("ipfix_deinit_template_array deinitialized template %i with success %i \n", i, ret);
+                DPRINTFL(MSG_VDEBUG, "ipfix_deinit_template_array deinitialized template %i with success %i ", i, ret);
                 // end debugging
         }
         free(exporter->template_arr);
@@ -857,7 +724,7 @@ static int ipfix_deinit_template_array(i
 
 
 /*
- * Updates the template sendbuffers
+ * Updates the template sendbuffer
  * will be called, after a template has been added or removed
  */
 static int ipfix_update_template_sendbuffer (ipfix_exporter *exporter)
@@ -877,69 +744,27 @@ static int ipfix_update_template_sendbuf
         }
 
         ipfix_sendbuffer* t_sendbuf = exporter->template_sendbuffer;
-	ipfix_sendbuffer* sctp_sendbuf = exporter->sctp_template_sendbuffer;
-
-        // clean the template sendbuffers
+	
+        // clean the template sendbuffer
         ret=ipfix_reset_sendbuffer(t_sendbuf);
-	ret=ipfix_reset_sendbuffer(sctp_sendbuf);
 
         // place all valid templates to the template sendbuffer
         // could be done just like put_data_field:
 
         for (i = 0; i < exporter->ipfix_lo_template_maxsize; i++ )  {
-                switch (exporter->template_arr[i].valid) {
-                	case (TOBEDELETED):
-				// free memory and mark UNUSED
-				ipfix_deinit_template_set(exporter, &(exporter->template_arr[i]) );
-				break;
-			case (COMMITED): // send to SCTP and UDP collectors and mark as SENT
-				if (sctp_sendbuf->current >= IPFIX_MAX_SENDBUFSIZE-2 ) {
-					msg(MSG_ERROR, "IPFIX: SCTP template sendbuffer too small to handle more than %i entries", sctp_sendbuf->current);
-					return -1;
-                        	}
-                        	if (t_sendbuf->current >= IPFIX_MAX_SENDBUFSIZE-2 ) {
-					msg(MSG_ERROR, "IPFIX: UDP template sendbuffer too small to handle more than %i entries", t_sendbuf->current);
-					return -1;
-                        	}
-				sctp_sendbuf->entries[ sctp_sendbuf->current ].iov_base = exporter->template_arr[i].template_fields;
-                        	sctp_sendbuf->entries[ sctp_sendbuf->current ].iov_len =  exporter->template_arr[i].fields_length;
-                        	sctp_sendbuf->current++;
-                        	sctp_sendbuf->committed_data_length +=  exporter->template_arr[i].fields_length;
-				
-				t_sendbuf->entries[ t_sendbuf->current ].iov_base = exporter->template_arr[i].template_fields;
-				t_sendbuf->entries[ t_sendbuf->current ].iov_len =  exporter->template_arr[i].fields_length;
-				t_sendbuf->current++;
-				t_sendbuf->committed_data_length +=  exporter->template_arr[i].fields_length;
-                        	
-                        	exporter->template_arr[i].valid = SENT;
-                        	msg(MSG_DEBUG, "IPFIX: ipfix_update_template_sendbuffer: Commited template ID: %d added to sendbuffers", exporter->template_arr[i].template_id);
-                        	break;
-                	case (SENT): // only to UDP collectors
-                		if (t_sendbuf->current >= IPFIX_MAX_SENDBUFSIZE-2 ) {
-					msg(MSG_ERROR, "IPFIX: UDP template sendbuffer too small to handle more than %i entries", t_sendbuf->current);
-					return -1;
-                        	}
-                		t_sendbuf->entries[ t_sendbuf->current ].iov_base = exporter->template_arr[i].template_fields;
-				t_sendbuf->entries[ t_sendbuf->current ].iov_len =  exporter->template_arr[i].fields_length;
-				t_sendbuf->current++;
-				t_sendbuf->committed_data_length +=  exporter->template_arr[i].fields_length;
-				msg(MSG_DEBUG, "IPFIX: ipfix_update_template_sendbuffer: Sent template ID: %d added to udp_sendbuffer", exporter->template_arr[i].template_id);
-                        	break;
-                	case (WITHDRAWN): // put the SCTP withdrawal message and mark TOBEDELETED
-                		if (sctp_sendbuf->current >= IPFIX_MAX_SENDBUFSIZE-2 ) {
-                                msg(MSG_ERROR, "IPFIX: SCTP template sendbuffer too small to handle more than %i entries", sctp_sendbuf->current);
+                // is the current template valid?
+                if(exporter->template_arr[i].valid==COMMITED) {
+                        // link the data to the sendbuffer:
+                        if (t_sendbuf->current >= IPFIX_MAX_SENDBUFSIZE-2 ) {
+                                msg(MSG_ERROR, "IPFIX: template sendbuffer too small to handle more than %i entries", t_sendbuf->current);
                                 return -1;
-				}
-				sctp_sendbuf->entries[ sctp_sendbuf->current ].iov_base = exporter->template_arr[i].template_fields;
-				sctp_sendbuf->entries[ sctp_sendbuf->current ].iov_len =  exporter->template_arr[i].fields_length;
-				sctp_sendbuf->current++;
-				sctp_sendbuf->committed_data_length +=  exporter->template_arr[i].fields_length;
-				
-				exporter->template_arr[i].valid = TOBEDELETED;
-				msg(MSG_DEBUG, "IPFIX: ipfix_update_template_sendbuffer: Withdrawal for template ID: %d added to sctp_sendbuffer", exporter->template_arr[i].template_id);
-				break;
-			default : // Do nothing : UNUSED or UNCLEAN
-				break;
+                        }
+
+                        t_sendbuf->entries[ t_sendbuf->current ].iov_base = exporter->template_arr[i].template_fields;
+                        t_sendbuf->entries[ t_sendbuf->current ].iov_len =  exporter->template_arr[i].fields_length;
+                        t_sendbuf->current++;
+                        // total_length += (*exporter).template_arr[i].fields_length;
+                        t_sendbuf->committed_data_length +=  exporter->template_arr[i].fields_length;
                 }
         } // end loop over all templates
 
@@ -961,87 +786,66 @@ static int ipfix_send_templates(ipfix_ex
 {
         int i;
         int ret=0;
-        int expired;
         // determine, if we need to send the template data:
         time_t time_now = time(NULL);
 
-        // has the timer expired? (for UDP)
-        expired = ( (time_now - exporter->last_template_transmission_time) >  exporter->template_transmission_timer);
+        // has the timer expired?
+        if ( (time_now - exporter->last_template_transmission_time) >  exporter->template_transmission_timer) {
 
-	// update the sendbuffers
-	ipfix_update_template_sendbuffer(exporter);
+                // send the template date
 
-	// send the sendbuffer to all collectors depending on their protocol
-	for (i = 0; i < exporter->collector_max_num; i++) {
-		// is the collector a valid target?
-		if ((*exporter).collector_arr[i].valid) {
-			DPRINTF("Sending template to exporter %s:%d Proto: %d\n",
-				exporter->collector_arr[i].ipv4address,
-				exporter->collector_arr[i].port_number,
-				exporter->collector_arr[i].protocol
-				);
-			switch(exporter->collector_arr[i].protocol){ 
-			case UDP:
-				if (expired && (exporter->template_sendbuffer->committed_data_length > 0)){
-					//Timer only used for UDP
-					exporter->last_template_transmission_time = time_now;
-					// update the sendbuffer header, as we must set the export time & sequence number!
-					ret = ipfix_prepend_header(exporter,
-						exporter->template_sendbuffer->committed_data_length,
-						exporter->template_sendbuffer
-					);
-					if(ret != 0 ) {
-						msg(MSG_ERROR, "IPFIX: sending templates failed");
-						return -1;
-					}
-					ret=writev(exporter->collector_arr[i].data_socket,//TODO:change for SCTP 
-	// 				(Alex: NOTE: Both streams are on the same socket -> only one socket is needed)
-						exporter->template_sendbuffer->entries,
-						exporter->template_sendbuffer->current
-						);
-					DPRINTF("ipfix_send_templates: %d TMPlate Bytes sent to UDP collectors\n",ret);	
-				}
-				break;
+                // hope, the template sendbuffer is valid.
 
-			case TCP:
-				msg(MSG_FATAL, "IPFIX: Transport Protocol TCP not implemented");
-				return -1;
-		
-			case SCTP:
-				if (exporter->sctp_template_sendbuffer->committed_data_length > 0) {
-					// update the sendbuffer header, as we must set the export time & sequence number!
-					ret = ipfix_prepend_header(exporter,
-						exporter->sctp_template_sendbuffer->committed_data_length,
-						exporter->sctp_template_sendbuffer
-					);
-					if(ret != 0 ) {
-						msg(MSG_ERROR, "IPFIX: sending templates failed");
-						return -1;
-					}
-					ret = sctp_sendmsgv(exporter->collector_arr[i].data_socket,
-						exporter->sctp_template_sendbuffer->entries,
-						exporter->sctp_template_sendbuffer->current,
-						(struct sockaddr*)&(exporter->collector_arr[i].addr),
-						sizeof(exporter->collector_arr[i].addr),
-						0,0,
-						0,//Stream Number
-						0,//packet lifetime in ms (0 = reliable, do not change for tamplates)
-						0
-						);
-					DPRINTF("ipfix_send_templates: %d TMPlate Bytes sent to SCTP collectors\n",ret);			
-				}
-				break;
+                // update the sendbuffer header, as we must set the export time & sequence number!
+                ret = ipfix_prepend_header(exporter,
+                                           exporter->template_sendbuffer->committed_data_length,
+                                           exporter->template_sendbuffer
+                                          );
 
-			default:
-				msg(MSG_FATAL, "IPFIX: Transport Protocol not supported");
-				return -1;	
-			}
- 			// TODO: we should also check, what writev returned. NO ERROR HANDLING IMPLEMENTED YET!
+                if(ret != 0 ) {
+                        msg(MSG_ERROR, "IPFIX: sending templates failed");
+                        return -1;
+                }
 
-		}
-	} // end exporter loop
+                exporter->last_template_transmission_time = time_now;
 
-	return 1;
+                // send the sendbuffer to all collectors
+                for (i = 0; i < exporter->collector_max_num; i++) {
+                        // is the collector a valid target?
+                        if ((*exporter).collector_arr[i].valid) {
+                                DPRINTFL(MSG_VDEBUG, "Sending template to exporter %s:%d",
+                                        exporter->collector_arr[i].ipv4address,
+                                        exporter->collector_arr[i].port_number
+                                       );
+#ifdef IPFIXLOLIB_RAWDIR_SUPPORT
+				if (exporter->collector_arr[i].protocol != RAWDIR) {
+#endif
+					ret=writev(exporter->collector_arr[i].data_socket,
+							exporter->template_sendbuffer->entries,
+							exporter->template_sendbuffer->current
+						  );
+#ifdef IPFIXLOLIB_RAWDIR_SUPPORT
+				} 
+				if (exporter->collector_arr[i].protocol == RAWDIR) {
+					char* packet_directory_path = exporter->collector_arr[i].packet_directory_path;
+					char fnamebuf[1024];
+					sprintf(fnamebuf, "%s/%08d", packet_directory_path, exporter->collector_arr[i].packets_written++);
+					int f = creat(fnamebuf, S_IRWXU | S_IRWXG);
+					ret=writev(f,
+							exporter->template_sendbuffer->entries,
+							exporter->template_sendbuffer->current
+						  );
+					close(f);
+				}
+#endif
+                                // TODO: we should also check, what writev returned. NO ERROR HANDLING IMPLEMENTED YET!
+
+                        }
+                } // end exporter loop
+
+                return 1;
+        } // end if export template.
+        return 0;
 }
 
 /*
@@ -1078,59 +882,50 @@ static int ipfix_send_data(ipfix_exporte
                         // is the collector a valid target?
                         if(exporter->collector_arr[i].valid) {
 #ifdef DEBUG
-                                DPRINTF("IPFIX: Sending to exporter %s\n", exporter->collector_arr[i].ipv4address);
+                                DPRINTFL(MSG_VDEBUG, "IPFIX: Sending to exporter %s", exporter->collector_arr[i].ipv4address);
 
                                 // debugging output of data buffer:
-                                DPRINTF("Sendbuffer contains %u bytes\n",  exporter->data_sendbuffer->committed_data_length );
-                                DPRINTF("Sendbuffer contains %u fields\n",  exporter->data_sendbuffer->committed );
+                                DPRINTFL(MSG_VDEBUG, "Sendbuffer contains %u bytes",  exporter->data_sendbuffer->committed_data_length );
+                                DPRINTFL(MSG_VDEBUG, "Sendbuffer contains %u fields",  exporter->data_sendbuffer->committed );
                                 int tested_length = 0;
                                 int j;
-                                int k;
+                                /*int k;*/
                                 for (j =0; j <  exporter->data_sendbuffer->committed; j++) {
                                         if(exporter->data_sendbuffer->entries[j].iov_len > 0 ) {
                                                 tested_length += exporter->data_sendbuffer->entries[j].iov_len;
-                                                DPRINTF ("Data Buffer [%i] has %u bytes\n", j, exporter->data_sendbuffer->entries[j].iov_len);
+                                                DPRINTFL (MSG_VDEBUG, "Data Buffer [%i] has %u bytes", j, exporter->data_sendbuffer->entries[j].iov_len);
 
-                                                for (k=0; k < exporter->data_sendbuffer->entries[j].iov_len; k++) {
-                                                        DPRINTF ("Data at  buf_vector[%i] pos %i is 0x%hx \n", j,k,   *(  (char*) ( (*(*exporter).data_sendbuffer).entries[j].iov_base+k) ) );
-                                                }
+                                                /*for (k=0; k < exporter->data_sendbuffer->entries[j].iov_len; k++) {
+                                                        DPRINTFL (MSG_VDEBUG, "Data at  buf_vector[%i] pos %i is 0x%hx", j,k,   *(  (char*) ( (*(*exporter).data_sendbuffer).entries[j].iov_base+k) ) );
+                                                }*/
                                         }
                                 }
-                                DPRINTF("IPFIX: Sendbuffer really contains %u bytes!\n", tested_length );
+                                DPRINTFL(MSG_VDEBUG, "IPFIX: Sendbuffer really contains %u bytes!", tested_length );
 #endif
-				switch(exporter->collector_arr[i].protocol){
-				case UDP:
-					ret=writev( exporter->collector_arr[i].data_socket,
-						exporter->data_sendbuffer->entries,
-						exporter->data_sendbuffer->committed
-						);
-
-					DPRINTF("ipfix_send_data: %d Data Bytes sent to UDP collectors\n",ret);	
-					// TODO: we should also check, what writev returned. NO ERROR HANDLING IMPLEMENTED YET!
-					break;
-
-				case TCP:
-					msg(MSG_FATAL, "IPFIX: Transport Protocol TCP not implemented");
-					return -1;
-			
-				case SCTP:
-					ret = sctp_sendmsgv(exporter->collector_arr[i].data_socket,
-						exporter->data_sendbuffer->entries,
-						exporter->data_sendbuffer->committed,
-						(struct sockaddr*)&(exporter->collector_arr[i].addr),
-						sizeof(exporter->collector_arr[i].addr),
-						0,0,
-						0,//Stream Number
-						exporter->sctp_lifetime,//packet lifetime in ms(0 = reliable )
-						0
-						);
-					DPRINTF("ipfix_send_data: %d Data Bytes sent to SCTP collectors\n",ret);
-					break;
-				default:
-					msg(MSG_FATAL, "IPFIX: Transport Protocol not supported");
-					return -1;	
-                        	}
-                        	
+				
+
+#ifdef IPFIXLOLIB_RAWDIR_SUPPORT
+				if (exporter->collector_arr[i].protocol != RAWDIR) {
+#endif
+					ret=writev(exporter->collector_arr[i].data_socket,
+							exporter->data_sendbuffer->entries,
+							exporter->data_sendbuffer->current
+						  );
+#ifdef IPFIXLOLIB_RAWDIR_SUPPORT
+				}
+				if (exporter->collector_arr[i].protocol == RAWDIR) {
+					char* packet_directory_path = exporter->collector_arr[i].packet_directory_path;
+					char fnamebuf[1024];
+					sprintf(fnamebuf, "%s/%08d", packet_directory_path, exporter->collector_arr[i].packets_written++);
+					int f = creat(fnamebuf, S_IRWXU | S_IRWXG);
+					ret=writev(f,
+							exporter->data_sendbuffer->entries,
+							exporter->data_sendbuffer->current
+						  );
+					close(f);
+				}
+#endif
+                                // TODO: we should also check, what writev returned. NO ERROR HANDLING IMPLEMENTED YET!
                         }
                 } // end exporter loop
                 ret = 1;
@@ -1230,7 +1025,7 @@ int ipfix_start_data_set(ipfix_exporter 
         exporter->data_sendbuffer->entries[exporter->data_sendbuffer->current].iov_len = sizeof(ipfix_set_header);
 
         exporter->data_sendbuffer->current++;
-        DPRINTF("start_data_set: exporter->data_sendbuffer->current %i\n", exporter->data_sendbuffer->current);
+        DPRINTF("start_data_set: exporter->data_sendbuffer->current %i", exporter->data_sendbuffer->current);
 
 	// set marker to current in order to avoid deletion of set header with ipfix_cancel_data_fields_upto_marker()
 	exporter->data_sendbuffer->marker = exporter->data_sendbuffer->current;
@@ -1385,34 +1180,22 @@ int ipfix_start_datatemplate_set (ipfix_
         int found_index = -1;
 	int datatemplate=(fixedfield_count || preceding) ? 1 : 0;
 
-        DPRINTF("ipfix_start_template_set: start\n");
-        found_index = ipfix_find_template(exporter, template_id, SENT);
+        DPRINTF("ipfix_start_template_set: start");
+        found_index = ipfix_find_template(exporter, template_id, COMMITED);
 
         // have we found a template?
         if(found_index >= 0) {
-                msg(MSG_DEBUG, "ipfix_start_template_set: template found at index %i , validity %d", found_index, exporter->template_arr[found_index].valid);
+                DPRINTF("ipfix_start_template_set: template found at index %i", found_index);
                 // we must overwrite the old template.
                 // first, clean up the old template:
-		switch (exporter->template_arr[found_index].valid){
-			case COMMITED:
-			case SENT:
-				// create a withdrawal message first
-				ipfix_remove_template_set(exporter, exporter->template_arr[found_index].template_id);
-			case WITHDRAWN:
-				// send withdrawal messages
-				ipfix_send_templates(exporter);
-			case UNCLEAN:
-			case TOBEDELETED:
-				// nothing to do, template can be deleted
-				ipfix_deinit_template_set(exporter, &(exporter->template_arr[found_index]));
-				break;
-			default:
-				msg(MSG_DEBUG, "IPFIX: ipfix_start_template_set: template valid flag ist UNUSED or wrong\n");	
-				break;
-		}
+
+                // remove the old template from memory!
+                exporter->template_arr[found_index].valid = UNUSED;
+                free(exporter->template_arr[found_index].template_fields) ;
+                exporter->template_arr[found_index].template_fields = NULL;
         } else {
                 /* allocate a new, free slot */
-                DPRINTF("ipfix_start_template_set: making new template\n");
+                DPRINTF("ipfix_start_template_set: making new template");
 
                 searching = TRUE;
 
@@ -1425,7 +1208,7 @@ int ipfix_start_datatemplate_set (ipfix_
                         return -1;
                 }
 
-                DPRINTF("ipfix_start_template_set: found_index: %i,  searching: %i, maxsize: %i\n",
+                DPRINTF("ipfix_start_template_set: found_index: %i,  searching: %i, maxsize: %i",
                         found_index, searching, exporter->ipfix_lo_template_maxsize
                        );
                 i = 0;
@@ -1443,7 +1226,7 @@ int ipfix_start_datatemplate_set (ipfix_
                                 exporter->template_arr[i].template_fields = NULL;
                                 // TODO: maybe check, if this field is not null. Might only happen, when
                                 // asynchronous threads change the template fields.
-                                DPRINTF("ipfix_start_template_set: free slot found at %i \n", found_index);
+                                DPRINTF("ipfix_start_template_set: free slot found at %i ", found_index);
                         }
                         i++;
                 }
@@ -1458,7 +1241,7 @@ int ipfix_start_datatemplate_set (ipfix_
                 char *p_pos;
                 char *p_end;
 
-                DPRINTF("ipfix_start_template_set: initializing new slot\n");
+                DPRINTF("ipfix_start_template_set: initializing new slot");
                 // allocate memory for the template's fields:
                 // maximum length of the data: 8 bytes for each field, as one field contains:
                 // field type, field length (2*2bytes)
@@ -1504,8 +1287,8 @@ int ipfix_start_datatemplate_set (ipfix_
 
                 // does this work?
                 // (*exporter).template_arr[found_index].fields_length += 8;
-                DPRINTF("ipfix_start_template_set: max_fields_len %u \n", exporter->template_arr[found_index].max_fields_length);
-                DPRINTF("ipfix_start_template_set: fields_len %u \n", exporter->template_arr[found_index].fields_length);
+                DPRINTF("ipfix_start_template_set: max_fields_len %u ", exporter->template_arr[found_index].max_fields_length);
+                DPRINTF("ipfix_start_template_set: fieldss_len %u ", exporter->template_arr[found_index].fields_length);
         } else return -1;
 
         return 0;
@@ -1557,18 +1340,18 @@ int ipfix_put_template_field(ipfix_expor
         // end of the buffer
         p_end = p_pos + exporter->template_arr[found_index].max_fields_length;
 
-        DPRINTF("ipfix_put_template_field: template found at %d\n", found_index);
-        DPRINTF("ipfix_put_template_field: A p_pos %p, p_end %p\n", p_pos, p_end);
-        DPRINTF("ipfix_put_template_field: max_fields_len %d\n", exporter->template_arr[found_index].max_fields_length);
-        DPRINTF("ipfix_put_template_field: fields_len %d\n", exporter->template_arr[found_index].fields_length);
+        DPRINTFL(MSG_VDEBUG, "ipfix_put_template_field: template found at %d", found_index);
+        DPRINTFL(MSG_VDEBUG, "ipfix_put_template_field: A p_pos %p, p_end %p", p_pos, p_end);
+        DPRINTFL(MSG_VDEBUG, "ipfix_put_template_field: max_fields_len %d", exporter->template_arr[found_index].max_fields_length);
+        DPRINTFL(MSG_VDEBUG, "ipfix_put_template_field: fieldss_len %d", exporter->template_arr[found_index].fields_length);
 
         // add offset to the buffer's beginning: this is, where we will write to.
         p_pos += exporter->template_arr[found_index].fields_length;
 
-        DPRINTF("ipfix_put_template_field: B p_pos %p, p_end %p\n", p_pos, p_end);
+        DPRINTFL(MSG_VDEBUG, "ipfix_put_template_field: B p_pos %p, p_end %p", p_pos, p_end);
 
         if(enterprise_bit_set) {
-                DPRINTF("Notice: using enterprise ID %d with data %d\n", template_id, enterprise_id);
+                DPRINTFL(MSG_VDEBUG, "Notice: using enterprise ID %d with data %d", template_id, enterprise_id);
         }
 
         // now write the fields to the buffer:
@@ -1624,7 +1407,7 @@ int ipfix_put_template_data(ipfix_export
 
         /* test for a valid slot */
         if ( found_index < 0 || found_index >= exporter->ipfix_lo_template_maxsize ) {
-                fprintf (stderr, "Template not found. \n");
+                fprintf (stderr, "Template not found. ");
                 return -1;
         }
 
@@ -1637,15 +1420,15 @@ int ipfix_put_template_data(ipfix_export
         // end of the buffer
         p_end = p_pos +  (*exporter).template_arr[found_index].max_fields_length;
 
-        DPRINTF("ipfix_put_template_data: template found at %i\n", found_index);
-        DPRINTF("ipfix_put_template_data: A p_pos %p, p_end %p\n", p_pos, p_end);
-        DPRINTF("ipfix_put_template_data: max_fields_len %u \n", (*exporter).template_arr[found_index].max_fields_length);
-        DPRINTF("ipfix_put_template_data: fieldss_len %u \n", (*exporter).template_arr[found_index].fields_length);
+        DPRINTFL(MSG_VDEBUG, "ipfix_put_template_data: template found at %i", found_index);
+        DPRINTFL(MSG_VDEBUG, "ipfix_put_template_data: A p_pos %p, p_end %p", p_pos, p_end);
+        DPRINTFL(MSG_VDEBUG, "ipfix_put_template_data: max_fields_len %u ", (*exporter).template_arr[found_index].max_fields_length);
+        DPRINTFL(MSG_VDEBUG, "ipfix_put_template_data: fieldss_len %u ", (*exporter).template_arr[found_index].fields_length);
 
         // add offset to the buffer's beginning: this is, where we will write to.
         p_pos += (*exporter).template_arr[found_index].fields_length;
 
-        DPRINTF("ipfix_put_template_data: B p_pos %p, p_end %p\n", p_pos, p_end);
+        DPRINTFL(MSG_VDEBUG, "ipfix_put_template_data: B p_pos %p, p_end %p", p_pos, p_end);
 
 	for(i = 0; i < data_length; i++) {
 		ret = write_octet(&p_pos, p_end, *(((uint8_t*)data)+i) );
@@ -1699,6 +1482,9 @@ int ipfix_end_template_set(ipfix_exporte
         // call the template valid
         templ->valid = COMMITED;
 
+        // commit the template buffer to the sendbuffer
+        ipfix_update_template_sendbuffer(exporter);
+
         return 0;
 }
 
@@ -1717,7 +1503,7 @@ int ipfix_deinit_template_set(ipfix_expo
         // won't be initialized. So you'll get a lot of warning messages, which are just fine...
 
         if(templ == NULL) {
-                DPRINTF("ipfix_deinit_template_set: Cannot free template. Template is already NULL\n!");
+                DPRINTF("ipfix_deinit_template_set: Cannot free template. Template is already NULL!");
                 return -1;
         }
 
@@ -1725,49 +1511,27 @@ int ipfix_deinit_template_set(ipfix_expo
         // might try to write to an unclean template!!!
 
         // first test, if we can free this template
-        if (templ->valid == UNUSED) {
-		DPRINTF("ipfix_deinit_template_set: Cannot free template. Template is UNUSED\n");
-                return -1;
-        } else {
-        	msg(MSG_DEBUG,"IPFIX: ipfix_deinit_template_set: deleting Template ID: %d validity: %d", templ->template_id, templ->valid);
-		templ->valid = UNUSED;
-		free(templ->template_fields);
+        if ( (templ->valid == COMMITED) || (templ->valid == UNCLEAN )) {
+                templ->valid = UNUSED;
+                free(templ->template_fields);
                 exporter->ipfix_lo_template_current_count--;
-	}
 
-        return 0;
-}
-
-// Set up time after that Templates are going to be resent
-int ipfix_set_template_transmission_timer(ipfix_exporter *exporter, uint32_t timer){
-	
-	if(timer < 0){
-		msg(MSG_ERROR, "IPFIX: invalid template retransmission timeout %d ", timer);
+        } else {
+                DPRINTF("ipfix_deinit_template_set: Cannot free template. Template is UNUSED");
                 return -1;
-        }else{
-		exporter->template_transmission_timer = timer;
-		return 0;
-	}
-}
+        }
 
-// Set up SCTP packet lifetime
-int ipfix_set_sctp_lifetime(ipfix_exporter *exporter, uint32_t lifetime){
-	
-	if(lifetime < 0){
-		msg(MSG_ERROR, "IPFIX: invalid SCTP packet lifetime %d ", lifetime);
-                return -1;
-        }else{
-		exporter->sctp_lifetime = lifetime;
-		return 0;
-	}
+        return 0;
 }
 
+
 /* check if the enterprise bit in an ID is set */
 int ipfix_enterprise_flag_set(uint16_t id)
 {
         return bit_set(id, IPFIX_ENTERPRISE_FLAG);
 }
 
+
 #ifdef __cplusplus
 }
 #endif
